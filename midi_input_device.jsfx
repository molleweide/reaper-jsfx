desc: molleweide custom midi device preprocessor
author: molleweide
version: 1.0

import my_variables.jsfx-inc
import my_functions.jsfx-inc

/*
   LINKS

   - MIDI SPEC: http://www.petesqbsite.com/sections/express/issue18/midifilespart1.html
   - MIDI TUTORIAL BIG: https://www.admiralbumblebee.com/music/2018/02/08/Write-a-Reaper-MIDI-JSFX-from-scratch.html#for-programmers

   TODO ////////////////////////////////////

    - merge qmk and grand into one statement

    - reset global vel when select qmk single?

    - split channel / notes
      L channel switching
      R = same note different vel
      >>> transpore should still work.

    - split ch/vel/mult note out put

    - config file list of midi devices > create custom command > set midi_device for sel tracks.
        1. research > are there any good existing stuff
        2. loop through list and check if exists...

    - action > force only one rec armed track at once

    - split kit > add ability to select output ranges for drumkit

    - hold down `UPDATE REGION`
        1. setState()=REGION_CHANGE_MODE
        2. press region that requires change
        3. input 2 digit change key.
        4. add key for resetting the current sequence

    - walk through reateam fx and clone everything over to my repo
      think about how everything can be divided up into modules
        how can I make this into my personal super library for
          managing midi.
            how can this become a growing process so that I can develop from time to time
              and focus on producing
                how can this become a growing process so that I can develop from time to time
                  and focus on producing.

  MIDI VIM

    - how do I differentiate messages between multiple rec armed instances?
    - what is the fastest way for changing and setting up multiple regions (ranges)
      >>> proposal
        1. enter switch mode
        2. press the region I want to setup.
        3. input start note for region.

   VIM ////////////////////////////////////

    - learn vimscript
   - make eel syntax into plugin >> publish to github
   - vim indent anything plugin?
   - article on indentation: http://psy.swansea.ac.uk/staff/carter/vim/vim_indent.htm
   - make plugin installable with all of the standard plugin managers

 */

slider1:24<1,127,1>ROOT
slider2:0<0,2,1{QMK,GRAND_PIANO,DRUMKIT}>DEVICE
slider3:0<0,2,1{QMK_SINGLE,QMK_FULL,QMK_SPLIT,GRAND_FULL,QMK_SPLIT_CH}>MODE

out_pin:none
out_pin:none

@slider
SINGLE_ROOT_NOTE = slider1;
MIDI_DEVICE = slider2;
MODE = slider3;

@block
while (
    //input = midirecv(offset,msg1,msg23);
    input = midirecv(offset,msg1,msg2,msg3);
    input ? (

      midi_in_type = msg1&TYPE_MASK; // TYPE
      midi_in_channel = msg1&CHANNEL_MASK; // channel
      midi_in_note = msg2;
      midi_in_vel = msg3;

      // QMK ////////////////////////////////////////////////////////////////////
      MIDI_DEVICE == DEVICE_QMK ? (
          midi_in_type == NOTE_ON && midi_in_vel > 0 ? (
            note_inside = filter_check(MODE, midi_in_note);
            (note_inside > 0) ? ( // inside
              //midisend(offset,msg1,note_inside+GLOBAL_VEL*256); // set channel
              midisend(offset,midi_in_type+midi_in_channel,note_inside,GLOBAL_VEL);
            ):( // outside
              WAS_FILTERED[midi_in_note] = 1;
              qmk_handleOtherKeys(MODE,midi_in_note); // set global_vel / global_ch here
            );
          ):
          midi_in_type == NOTE_OFF || (midi_in_type == NOTE_ON && midi_in_vel == 0 ) ? (
            WAS_FILTERED[midi_in_note] ? (
              WAS_FILTERED[midi_in_note] = 0;
              ):(
                note_off_inside = filter_check(MODE, midi_in_note);
                //midisend(offset,msg1,note_off_inside+GLOBAL_VEL*256);
                midisend(offset,midi_in_type+midi_in_channel,note_off_inside,GLOBAL_VEL);
                );
            );

          PASS_THRU_CC ? (
              midisend(mpos, msg1, msg23);
              );
      );
              // GRAND_PIANO ////////////////////////////////////////////////////////////////////

      MIDI_DEVICE == DEVICE_GRAND_PIANO ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              midi_in_type == NOTE_ON && midi_in_vel > 0 ? (
                filter = filter_check(MODE, midi_in_note);
                (!filter) ? (
                  midi_in_note = grand_computeNoteOut(MODE, midi_in_note);
                  midisend(offset,midi_in_type+midi_in_channel,note_inside,midi_in_vel);
                  //midisend(offset,msg1,midi_in_note+midi_in_vel*256);
                  ):(
                    WAS_FILTERED[midi_in_note] = 1;
                    grand_handleOtherKeys(MODE,midi_in_note);
                    );
                ): // NOTE_ON

              // midi_in_note OFFs /////////////////////////////////////////////////////
              midi_in_type == NOTE_OFF || (midi_in_type == NOTE_ON && midi_in_vel == 0 ) ? (

                WAS_FILTERED[midi_in_note] ? (
                  WAS_FILTERED[midi_in_note] = 0;
                  ):(
                    note_off_inside = grand_computeNoteOut(MODE, midi_in_note);
                    midisend(offset,msg1,note_off_inside+midi_in_vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
              ); // PASS_THRU_CC
        ); // DEVICE_GRAND_PIANO
      ); // input ? ()
    input;
);
