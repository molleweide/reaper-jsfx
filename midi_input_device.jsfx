desc: molleweide custom midi device preprocessor
author: molleweide
version: 1.0

/*
   LINKS

   - MIDI SPEC: http://www.petesqbsite.com/sections/express/issue18/midifilespart1.html
   - MIDI TUTORIAL BIG: https://www.admiralbumblebee.com/music/2018/02/08/Write-a-Reaper-MIDI-JSFX-from-scratch.html#for-programmers

   GOAL ////////////////////////////////////

   make it easy to update interaction >> let configs and templates arise over time.

   TODO ////////////////////////////////////

   - send reset midi message
      >> on transpore/layer shift release all notes stored in WAS_FILTERED
      >> update slider on transpose

    - rename all device/mode to start with prefix >> easy handle/read

    - split note / vel
      R = single note output
      L = left side outputs velocity
      >>> transpose should still work.

    - config file list of midi devices > create custom command > set midi_device for sel tracks.
        1. research > are there any good existing stuff
        2. loop through list and check if exists...

    - split channel / notes
      L channel switching
      R = note output
      >>> transpore should still work.

    - split ch/vel/mult note out put

    - action > force only one rec armed track at once

    - split kit > add ability to select output ranges for drumkit

    - hold down `UPDATE REGION`
        1. setState()=REGION_CHANGE_MODE
        2. press region that requires change
        3. input 2 digit change key.
        4. add key for resetting the current sequence

  MIDI VIM

    - how do I differentiate messages between multiple rec armed instances?
    - what is the fastest way for changing and setting up multiple regions (ranges)
      >>> proposal
        1. enter switch mode
        2. press the region I want to setup.
        3. input start note for region.

   VIM ////////////////////////////////////

   - make eel syntax into plugin >> publish to github
   - vim indent anything plugin?
   - article on indentation: http://psy.swansea.ac.uk/staff/carter/vim/vim_indent.htm
   - make plugin installable with all of the standard plugin managers

   oooh!! it seems it would be possible to create sort of like a mini vim language for setting up the
   midi instruments that I am using.

 */

slider1:24<1,127,1>ROOT
slider2:0<0,2,1{QMK,GRAND_PIANO,DRUMKIT}>DEVICE
slider3:0<0,2,1{QMK_SINGLE,QMK_FULL,QMK_SPLIT,GRAND_PIANO_FULL}>MODE

out_pin:none
out_pin:none

@init

NOTE_OFF = 8;
NOTE_ON = 9;

WAS_FILTERED = 1024;  // array for storing which notes are filtered

PASS_THRU_CC = 0;

SINGLE_ROOT_NOTE = 24; // reset transpose by setting this to 24
TRANSPOSE_SHIFT = 0;

// device..............
// MIDI_DEVICE = 0;
DEVICE_QMK = 0;
DEVICE_GRAND_PIANO = 1;

// modes..........
QMK_SINGLE_OUT = 0;
QMK_FULL_LINEAR = 1;
QMK_SPLIT = 2;
GRAND_PIANO_FULL_MODE = 3;

// qmk variables
QMK_NOTE_SHIFT_NORMALIZE = 48; // i have to look this up
QMK_FULL_HIGH = 85;
QMK_FULL_LOW = 48;
QMK_SINGLE_HIGH = QMK_FULL_HIGH;
QMK_SINGLE_LOW = 56;

QMK_ROW_HIGH_L_START = 76;
QMK_ROW_HIGH_L_END = 80;
QMK_ROW_HIGH_R_START = 81;
QMK_ROW_HIGH_R_END = 85;
QMK_ROW_MID_L_start = 66;
QMK_ROW_MID_L_end = 70;
QMK_ROW_MID_R_start = 71;
QMK_ROW_MID_R_end = 75;
QMK_ROW_LOW_L_START = 56;
QMK_ROW_LOW_L_END = 60;
QMK_ROW_LOW_R_START = 61;
QMK_ROW_LOW_R_END = 65; ////////////////////////////
QMK_ROW_BOTTOM_L_START = 48; /////////////////////////
QMK_ROW_BOTTOM_L_END = 50;
QMK_ROW_BOTTOM_R_START = 53;
QMK_ROW_BOTTOM_R_END = 55;
QMK_THUMB_INNER_L1 = 51;
QMK_THUMB_INNER_R1 = 52;

// grand piano variables
GPAND_PIANO_NOTE_SHIFT_NORMALIZE = 24;
GRAND_PIANO_HIGH = 108;
GRAND_PIANO_LOW = 33;


//TRANSPOSE_RESET = ;
KC_TRANSPOSE_THUMBS_DOWN = 50;
KC_TRANSPOSE_THUMBS_UP = 53;
KC_TRANSPOSE_PINKY_DOWN = 110;
KC_TRANSPOSE_PINKY_UP = 115;
KC_TRANSPOSE_RESET_1 = 86;
KC_TRANSPOSE_RESET_2 = 87;
KC_TRANSPOSE_RESET_3 = 88;
KC_TRANSPOSE_RESET_4 = 89;
KC_TRANSPOSE_RESET_5 = 90;

KC_GRAND_TRANSPOSE_UP = 25;
KC_GRAND_TRANSPOSE_DOWN = 24;
KC_GRAND_TRANSPOSE_RESET = 26;
KC_GRAND_RESET_ALL_NOTES = 27;

// check limits:  t < 0 ? t = 0 : t > 127 ? t = 127;
function transpose_up()(
    SINGLE_ROOT_NOTE < 127 ? (
      SINGLE_ROOT_NOTE += 1;
      );
);

function transpose_down()(
    SINGLE_ROOT_NOTE > 0 ? (
      SINGLE_ROOT_NOTE -= 1;
      );
);

function resetAllNotes()(
  // loop through all notes
  loop(127,
    i += 1;
    vel = 80;
    midisend(0,$x80,i+vel*256);
  );
);

// rename function to `qmk_handleOtherKeys()`
function qmh_handleOtherKeys(mode, input)(
    ( mode == QMK_SINGLE_OUT || mode == QMK_FULL_LINEAR || mode == QMK_SPLIT ) ? (
      input == KC_TRANSPOSE_RESET_1 ? SINGLE_ROOT_NOTE = 24;
      input == KC_TRANSPOSE_RESET_2 ? SINGLE_ROOT_NOTE = 36;
      input == KC_TRANSPOSE_RESET_3 ? SINGLE_ROOT_NOTE = 48;
      input == KC_TRANSPOSE_RESET_4 ? SINGLE_ROOT_NOTE = 60;
      input == KC_TRANSPOSE_RESET_5 ? SINGLE_ROOT_NOTE = 72;
      input == KC_TRANSPOSE_PINKY_UP ? transpose_up();
      input == KC_TRANSPOSE_PINKY_DOWN ? transpose_down();
    );

    mode == QMK_SINGLE_OUT ? (
      input == KC_TRANSPOSE_THUMBS_UP ? transpose_up();
      input == KC_TRANSPOSE_THUMBS_DOWN? transpose_down();
    );
    resetAllNotes();
);

function grand_handleOtherKeys(mode, input)(
  mode == GRAND_PIANO_FULL_MODE ? (
      input == KC_GRAND_TRANSPOSE_RESET ? SINGLE_ROOT_NOTE = 24;
      input == KC_GRAND_RESET_ALL_NOTES ? resetAllNotes();
      input == KC_GRAND_TRANSPOSE_UP ? transpose_up();
      input == KC_GRAND_TRANSPOSE_DOWN ? transpose_down();
  );
  resetAllNotes();
);
// RENAME TO NOTE ON / OFF INPUT GATE ??
function filter_check(mode, note) (
    mode == QMK_SINGLE_OUT ? (
      retval = (note < QMK_SINGLE_LOW || note > QMK_SINGLE_HIGH)
      && note != QMK_THUMB_INNER_L1 && note != QMK_THUMB_INNER_R1;
    );
    (mode == QMK_FULL_LINEAR || mode == QMK_SPLIT) ? (
      retval = note < QMK_FULL_LOW || note > QMK_FULL_HIGH;
    );
    mode == GRAND_PIANO_FULL_MODE ? (
      retval = note < GRAND_PIANO_LOW || note > GRAND_PIANO_HIGH;
    );
    retval;
);

// incoming notes range from 0 - 37
function qmk_mapSplitNotes(note)(
  // TODO
  //
  //  create function numInRange() ???

    // left side //////////////////
    (QMK_ROW_HIGH_L_START <= note && note <= QMK_ROW_HIGH_L_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 14;
      /* tmp_note = note - QMK_NOTE_SHIFT_NORMALIZE; */
    );
    (QMK_ROW_MID_L_START <= note && note <= QMK_ROW_MID_L_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 9;
    );
    (QMK_ROW_LOW_L_START <= note && note <= QMK_ROW_LOW_L_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 4;
    );
    (QMK_ROW_BOTTOM_L_START <= note && note <= QMK_ROW_BOTTOM_L_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE;
    );
    QMK_THUMB_INNER_L1 == note ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE;
    );
    // right side ////////////////
    (QMK_ROW_HIGH_R_START <= note && note <= QMK_ROW_HIGH_R_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 19;
    );
    (QMK_ROW_MID_R_START <= note && note <= QMK_ROW_MID_R_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 14;
    );
    (QMK_ROW_LOW_R_START <= note && note <= QMK_ROW_LOW_R_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 9;
    );
    (QMK_ROW_BOTTOM_R_START <= note && note <= QMK_ROW_BOTTOM_R_END) ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 4;
    );
    QMK_THUMB_INNER_R1 == note ? (
      retval = SINGLE_ROOT_NOTE + note - QMK_NOTE_SHIFT_NORMALIZE - 4;
    );

  retval;
);

// QMK OUTPUT NOTE MAPPING
function qmk_computeNoteOut(mode, note)(
    mode == QMK_SINGLE_OUT ? (
      retval = SINGLE_ROOT_NOTE;// compute retval with transpose shift
    );
    mode == QMK_FULL_LINEAR ? (
      // first subtract shift notes and then add ring
      tmp_note = note - QMK_NOTE_SHIFT_NORMALIZE;
      retval = SINGLE_ROOT_NOTE + tmp_note;
    );
    mode == QMK_SPLIT ? (
      retval = qmk_mapSplitNotes(note);
    );
    retval;
);

function grand_computeNoteOut(mode, note)(
    mode == GRAND_PIANO_FULL_MODE ? (
       retval = SINGLE_ROOT_NOTE + note - GPAND_PIANO_NOTE_SHIFT_NORMALIZE;
    );
    retval;
);

@slider
SINGLE_ROOT_NOTE = slider1;
MIDI_DEVICE = slider2;
MODE = slider3;

@block

// TODO
//
//  put midi cc pass thru at the end??
while (
    input = midirecv(offset,msg1,msg23);
    input ? ( // check if current track channel?

      statusHi = (msg1/16)|0;
      statusLo = (msg1-(statusHi*16))|0;
      note = msg23&127;
      vel =(msg23/256)|0;

      // QMK ////////////////////////////////////////////////////////////////////
      MIDI_DEVICE == DEVICE_QMK ? (

        MODE == QMK_SINGLE_OUT ? (
           // NOTE ONs ////////////////////////////////////////////////////////
          statusHi == NOTE_ON && vel > 0 ? (
            filter = filter_check(MODE, note);
            (!filter) ? (
              // create a function compute note
              // note = SINGLE_ROOT_NOTE; // SINGLE_ROOT_NOTE + TRANSPOSE_SHIFT
              note = qmk_computeNoteOut(MODE, note);
              midisend(offset,msg1,note+vel*256);
              ):(
                WAS_FILTERED[note] = 1;
                qmh_handleOtherKeys(MODE,note);
                );
            ):

          // NOTE OFFs /////////////////////////////////////////////////////
          statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

            WAS_FILTERED[note] ? (
              WAS_FILTERED[note] = 0;
              ):(
                //note = SINGLE_ROOT_NOTE; // SINGLE_ROOT_NOTE + TRANSPOSE_SHIFT
                note = qmk_computeNoteOut(MODE, note);
                midisend(offset,msg1,note+vel*256);
                );
            );

          PASS_THRU_CC ? (
              midisend(mpos, msg1, msg23);
              );
          ); // QMK_SINGLE_OUT

        MODE == QMK_FULL_LINEAR ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              statusHi == NOTE_ON && vel > 0 ? (
                filter = filter_check(MODE, note);
                (!filter) ? (
                  note = qmk_computeNoteOut(MODE, note);
                  midisend(offset,msg1,note+vel*256);
                  ):(
                    WAS_FILTERED[note] = 1;
                    qmh_handleOtherKeys(MODE,note);
                    );
                ): // NOTE_ON

              // NOTE OFFs /////////////////////////////////////////////////////
              statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                WAS_FILTERED[note] ? (
                  WAS_FILTERED[note] = 0;
                  ):(
                    note = qmk_computeNoteOut(MODE, note);
                    midisend(offset,msg1,note+vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
          ); // PASS_THRU_CC
        ); // QMK_FULL_LINEAR
        MODE == QMK_SPLIT ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              statusHi == NOTE_ON && vel > 0 ? (
                filter = filter_check(MODE, note);
                (!filter) ? (
                  note = qmk_computeNoteOut(MODE, note);
                  midisend(offset,msg1,note+vel*256);
                  ):(
                    WAS_FILTERED[note] = 1;
                    qmh_handleOtherKeys(MODE,note);
                    );
                ): // NOTE_ON

              // NOTE OFFs /////////////////////////////////////////////////////
              statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                WAS_FILTERED[note] ? (
                  WAS_FILTERED[note] = 0;
                  ):(
                    note = qmk_computeNoteOut(MODE, note);
                    midisend(offset,msg1,note+vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
          ); // PASS_THRU_CC
        ); // QMK_SPLIT_NOTE_AND_VEL
              /* MODE == QMK_SPLIT_MULT_CH_OUT ? (); */
              /* MODE == QMK_DRUM_KIT ? (); */
              );

              // GRAND_PIANO ////////////////////////////////////////////////////////////////////

          MIDI_DEVICE == DEVICE_GRAND_PIANO ? (
              MODE == GRAND_PIANO_FULL_MODE ? (
                      // NOTE ONs ////////////////////////////////////////////////////////
                      statusHi == NOTE_ON && vel > 0 ? (
                        filter = filter_check(MODE, note);
                        (!filter) ? (
                          note = grand_computeNoteOut(MODE, note);
                          midisend(offset,msg1,note+vel*256);
                          ):(
                            WAS_FILTERED[note] = 1;
                            grand_handleOtherKeys(MODE,note);
                            );
                        ): // NOTE_ON

                      // NOTE OFFs /////////////////////////////////////////////////////
                      statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                        WAS_FILTERED[note] ? (
                          WAS_FILTERED[note] = 0;
                          ):(
                            note = grand_computeNoteOut(MODE, note);
                            midisend(offset,msg1,note+vel*256);
                            );
                        ); // NOTE_OFF

                      PASS_THRU_CC ? (
                          midisend(mpos, msg1, msg23);
                      ); // PASS_THRU_CC
                  ); // MODE_GRAND_PIANO_FULL
                ); // DEVICE_GRAND_PIANO
              ); // input ? ()
              input;
              );
