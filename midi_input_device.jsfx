desc: molleweide custom midi device preprocessor
author: molleweide
version: 1.0

import my_variables.jsfx-inc
import my_functions.jsfx-inc

/*
   LINKS

   - MIDI SPEC: http://www.petesqbsite.com/sections/express/issue18/midifilespart1.html
   - MIDI TUTORIAL BIG: https://www.admiralbumblebee.com/music/2018/02/08/Write-a-Reaper-MIDI-JSFX-from-scratch.html#for-programmers

   TODO ////////////////////////////////////

    - refactor main loop into one branch per device.

   - how can I set VEL / CH global ?
        filterCheck >> only allow through notes
          return false if velocity side
        in the filtered area
          set global_vel/global_ch
          use these global variables for QMK

      split up files by device > put all qmk vars in qmk_functions, grand etc..

    - split note / vel
      R = single note output
      L = left side outputs velocity
      >>> transpose should still work.

    - split channel / notes
      L channel switching
      R = same note different vel
      >>> transpore should still work.


    - split ch/vel/mult note out put

    - config file list of midi devices > create custom command > set midi_device for sel tracks.
        1. research > are there any good existing stuff
        2. loop through list and check if exists...

    - action > force only one rec armed track at once

    - split kit > add ability to select output ranges for drumkit

    - hold down `UPDATE REGION`
        1. setState()=REGION_CHANGE_MODE
        2. press region that requires change
        3. input 2 digit change key.
        4. add key for resetting the current sequence

  MIDI VIM

    - how do I differentiate messages between multiple rec armed instances?
    - what is the fastest way for changing and setting up multiple regions (ranges)
      >>> proposal
        1. enter switch mode
        2. press the region I want to setup.
        3. input start note for region.

   VIM ////////////////////////////////////

   - make eel syntax into plugin >> publish to github
   - vim indent anything plugin?
   - article on indentation: http://psy.swansea.ac.uk/staff/carter/vim/vim_indent.htm
   - make plugin installable with all of the standard plugin managers

 */

slider1:24<1,127,1>ROOT
slider2:0<0,2,1{QMK,GRAND_PIANO,DRUMKIT}>DEVICE
slider3:0<0,2,1{QMK_SINGLE,QMK_FULL,QMK_SPLIT,GRAND_FULL,QMK_SPLIT_CH}>MODE

out_pin:none
out_pin:none

@init

NOTE_OFF = 8;
NOTE_ON = 9;

WAS_FILTERED = 1024;  // array for storing which notes are filtered

PASS_THRU_CC = 0;

GLOBAL_VEL = 80;

@slider
SINGLE_ROOT_NOTE = slider1;
MIDI_DEVICE = slider2;
MODE = slider3;

@block
while (
    input = midirecv(offset,msg1,msg23);
    input ? (

      statusHi = (msg1/16)|0;
      statusLo = (msg1-(statusHi*16))|0;
      note = msg23&127;
      vel =(msg23/256)|0;

      // QMK ////////////////////////////////////////////////////////////////////
      MIDI_DEVICE == DEVICE_QMK ? (

        MODE == MODE_QMK_SINGLE_BASIC ? (
           // NOTE ONs ////////////////////////////////////////////////////////
          statusHi == NOTE_ON && vel > 0 ? (
            filter = filter_check(MODE, note);
            (!filter) ? (
              note = qmk_computeNoteOut(MODE, note);
              midisend(offset,msg1,note+vel*256);
              ):(
                WAS_FILTERED[note] = 1;
                qmh_handleOtherKeys(MODE,note);

                );
            ):

          // NOTE OFFs /////////////////////////////////////////////////////
          statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

            WAS_FILTERED[note] ? (
              WAS_FILTERED[note] = 0;
              ):(
                note = qmk_computeNoteOut(MODE, note);
                midisend(offset,msg1,note+vel*256);
                );
            );

          PASS_THRU_CC ? (
              midisend(mpos, msg1, msg23);
              );
          ); // MODE_QMK_SINGLE_BASIC

        MODE == MODE_QMK_FULL_LINEAR ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              statusHi == NOTE_ON && vel > 0 ? (
                filter = filter_check(MODE, note);
                (!filter) ? (
                  note = qmk_computeNoteOut(MODE, note);
                  midisend(offset,msg1,note+vel*256);
                  ):(
                    WAS_FILTERED[note] = 1;
                    qmh_handleOtherKeys(MODE,note);
                    );
                ): // NOTE_ON

              // NOTE OFFs /////////////////////////////////////////////////////
              statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                WAS_FILTERED[note] ? (
                  WAS_FILTERED[note] = 0;
                  ):(
                    note = qmk_computeNoteOut(MODE, note);
                    midisend(offset,msg1,note+vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
          ); // PASS_THRU_CC
        ); // MODE_QMK_FULL_LINEAR
        MODE == MODE_QMK_SPLIT_VEL_NOTE ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              statusHi == NOTE_ON && vel > 0 ? (
                filter = filter_check(MODE, note);
                (!filter) ? (
                  note = qmk_computeNoteOut(MODE, note);

                  // this won_t work because I have to set the global vel and
                  // not just here.
                  /* GLOBAL_VEL = qmk_getVelOut(MODE, note); */
                  midisend(offset,msg1,note+GLOBAL_VEL*256);
                  ):(
                    WAS_FILTERED[note] = 1;
                    qmh_handleOtherKeys(MODE,note);
                    );
                ): // NOTE_ON

              // NOTE OFFs /////////////////////////////////////////////////////
              statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                WAS_FILTERED[note] ? (
                  WAS_FILTERED[note] = 0;
                  ):(
                    note = qmk_computeNoteOut(MODE, note);
                    midisend(offset,msg1,note+vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
          ); // PASS_THRU_CC
        ); // MODE_QMK_SPLIT_NOTE_AND_VEL

        MODE == MODE_QMK_SPLIT_MULT_CH ? (
              // NOTE ONs ////////////////////////////////////////////////////////
              statusHi == NOTE_ON && vel > 0 ? (
                filter = filter_check(MODE, note);
                (!filter) ? (
                  note = qmk_computeNoteOut(MODE, note);
                  midisend(offset,msg1,note+vel*256);
                  ):(
                    WAS_FILTERED[note] = 1;
                    qmh_handleOtherKeys(MODE,note);
                    );
                ): // NOTE_ON

              // NOTE OFFs /////////////////////////////////////////////////////
              statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                WAS_FILTERED[note] ? (
                  WAS_FILTERED[note] = 0;
                  ):(
                    note = qmk_computeNoteOut(MODE, note);
                    midisend(offset,msg1,note+vel*256);
                    );
                ); // NOTE_OFF

              PASS_THRU_CC ? (
                  midisend(mpos, msg1, msg23);
          ); // PASS_THRU_CC
        ); // MODE_QMK_SPLIT_NOTE_AND_VEL
      );
              // GRAND_PIANO ////////////////////////////////////////////////////////////////////

      MIDI_DEVICE == DEVICE_GRAND_PIANO ? (
              MODE == MODE_GRAND_PIANO_FULL ? (
                      // NOTE ONs ////////////////////////////////////////////////////////
                      statusHi == NOTE_ON && vel > 0 ? (
                        filter = filter_check(MODE, note);
                        (!filter) ? (
                          note = grand_computeNoteOut(MODE, note);
                          midisend(offset,msg1,note+vel*256);
                          ):(
                            WAS_FILTERED[note] = 1;
                            grand_handleOtherKeys(MODE,note);
                            );
                        ): // NOTE_ON

                      // NOTE OFFs /////////////////////////////////////////////////////
                      statusHi == NOTE_OFF || (statusHi == NOTE_ON && vel == 0 ) ? (

                        WAS_FILTERED[note] ? (
                          WAS_FILTERED[note] = 0;
                          ):(
                            note = grand_computeNoteOut(MODE, note);
                            midisend(offset,msg1,note+vel*256);
                            );
                        ); // NOTE_OFF

                      PASS_THRU_CC ? (
                          midisend(mpos, msg1, msg23);
                      ); // PASS_THRU_CC
                  ); // MODE_GRAND_PIANO_FULL
                ); // DEVICE_GRAND_PIANO
              ); // input ? ()
              input;
);
